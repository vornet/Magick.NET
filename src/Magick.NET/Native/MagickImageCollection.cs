// Copyright Dirk Lemstra https://github.com/dlemstra/Magick.NET.
// Licensed under the Apache License, Version 2.0.
// <auto-generated/>
#nullable enable

using System;
using System.Security;
using System.Runtime.InteropServices;

#if Q8
using QuantumType = System.Byte;
#elif Q16
using QuantumType = System.UInt16;
#elif Q16HDRI
using QuantumType = System.Single;
#else
#error Not implemented!
#endif

namespace ImageMagick
{
    public partial class MagickImageCollection
    {
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private delegate long ReadWriteStreamDelegate(IntPtr data, UIntPtr length, IntPtr user_data);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private delegate long SeekStreamDelegate(long offset, IntPtr whence, IntPtr user_data);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private delegate long TellStreamDelegate(IntPtr user_data);
        [SuppressUnmanagedCodeSecurity]
        private static unsafe class NativeMethods
        {
            #if PLATFORM_x64 || PLATFORM_AnyCPU
            public static class X64
            {
                #if PLATFORM_AnyCPU
                static X64() { NativeLibraryLoader.Load(); }
                #endif
                [DllImport(NativeLibrary.X64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Append(IntPtr image, [MarshalAs(UnmanagedType.Bool)] bool stack, out IntPtr exception);
                [DllImport(NativeLibrary.X64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Coalesce(IntPtr image, out IntPtr exception);
                [DllImport(NativeLibrary.X64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Combine(IntPtr image, UIntPtr colorSpace, out IntPtr exception);
                [DllImport(NativeLibrary.X64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Complex(IntPtr image, UIntPtr complexOperator, out IntPtr exception);
                [DllImport(NativeLibrary.X64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Deconstruct(IntPtr image, out IntPtr exception);
                [DllImport(NativeLibrary.X64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern void MagickImageCollection_Dispose(IntPtr value);
                [DllImport(NativeLibrary.X64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Evaluate(IntPtr image, UIntPtr evaluateOperator, out IntPtr exception);
                [DllImport(NativeLibrary.X64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern void MagickImageCollection_Map(IntPtr image, IntPtr settings, IntPtr remapImage, out IntPtr exception);
                [DllImport(NativeLibrary.X64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Merge(IntPtr image, UIntPtr method, out IntPtr exception);
                [DllImport(NativeLibrary.X64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Montage(IntPtr image, IntPtr settings, out IntPtr exception);
                [DllImport(NativeLibrary.X64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Morph(IntPtr image, UIntPtr frames, out IntPtr exception);
                [DllImport(NativeLibrary.X64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Optimize(IntPtr image, out IntPtr exception);
                [DllImport(NativeLibrary.X64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_OptimizePlus(IntPtr image, out IntPtr exception);
                [DllImport(NativeLibrary.X64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern void MagickImageCollection_OptimizeTransparency(IntPtr image, out IntPtr exception);
                [DllImport(NativeLibrary.X64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Polynomial(IntPtr image, double* terms, UIntPtr length, out IntPtr exception);
                [DllImport(NativeLibrary.X64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern void MagickImageCollection_Quantize(IntPtr image, IntPtr settings, out IntPtr exception);
                [DllImport(NativeLibrary.X64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_ReadBlob(IntPtr settings, byte* data, UIntPtr offset, UIntPtr length, out IntPtr exception);
                [DllImport(NativeLibrary.X64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_ReadFile(IntPtr settings, out IntPtr exception);
                [DllImport(NativeLibrary.X64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_ReadStream(IntPtr settings, ReadWriteStreamDelegate? reader, SeekStreamDelegate? seeker, TellStreamDelegate? teller, out IntPtr exception);
                [DllImport(NativeLibrary.X64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Smush(IntPtr image, IntPtr offset, [MarshalAs(UnmanagedType.Bool)] bool stack, out IntPtr exception);
                [DllImport(NativeLibrary.X64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern void MagickImageCollection_WriteFile(IntPtr image, IntPtr settings, out IntPtr exception);
                [DllImport(NativeLibrary.X64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern void MagickImageCollection_WriteStream(IntPtr image, IntPtr settings, ReadWriteStreamDelegate? writer, SeekStreamDelegate? seeker, TellStreamDelegate? teller, ReadWriteStreamDelegate? reader, out IntPtr exception);
            }
            #endif
            #if PLATFORM_x86 || PLATFORM_AnyCPU
            public static class X86
            {
                #if PLATFORM_AnyCPU
                static X86() { NativeLibraryLoader.Load(); }
                #endif
                [DllImport(NativeLibrary.X86Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Append(IntPtr image, [MarshalAs(UnmanagedType.Bool)] bool stack, out IntPtr exception);
                [DllImport(NativeLibrary.X86Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Coalesce(IntPtr image, out IntPtr exception);
                [DllImport(NativeLibrary.X86Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Combine(IntPtr image, UIntPtr colorSpace, out IntPtr exception);
                [DllImport(NativeLibrary.X86Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Complex(IntPtr image, UIntPtr complexOperator, out IntPtr exception);
                [DllImport(NativeLibrary.X86Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Deconstruct(IntPtr image, out IntPtr exception);
                [DllImport(NativeLibrary.X86Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern void MagickImageCollection_Dispose(IntPtr value);
                [DllImport(NativeLibrary.X86Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Evaluate(IntPtr image, UIntPtr evaluateOperator, out IntPtr exception);
                [DllImport(NativeLibrary.X86Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern void MagickImageCollection_Map(IntPtr image, IntPtr settings, IntPtr remapImage, out IntPtr exception);
                [DllImport(NativeLibrary.X86Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Merge(IntPtr image, UIntPtr method, out IntPtr exception);
                [DllImport(NativeLibrary.X86Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Montage(IntPtr image, IntPtr settings, out IntPtr exception);
                [DllImport(NativeLibrary.X86Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Morph(IntPtr image, UIntPtr frames, out IntPtr exception);
                [DllImport(NativeLibrary.X86Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Optimize(IntPtr image, out IntPtr exception);
                [DllImport(NativeLibrary.X86Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_OptimizePlus(IntPtr image, out IntPtr exception);
                [DllImport(NativeLibrary.X86Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern void MagickImageCollection_OptimizeTransparency(IntPtr image, out IntPtr exception);
                [DllImport(NativeLibrary.X86Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Polynomial(IntPtr image, double* terms, UIntPtr length, out IntPtr exception);
                [DllImport(NativeLibrary.X86Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern void MagickImageCollection_Quantize(IntPtr image, IntPtr settings, out IntPtr exception);
                [DllImport(NativeLibrary.X86Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_ReadBlob(IntPtr settings, byte* data, UIntPtr offset, UIntPtr length, out IntPtr exception);
                [DllImport(NativeLibrary.X86Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_ReadFile(IntPtr settings, out IntPtr exception);
                [DllImport(NativeLibrary.X86Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_ReadStream(IntPtr settings, ReadWriteStreamDelegate? reader, SeekStreamDelegate? seeker, TellStreamDelegate? teller, out IntPtr exception);
                [DllImport(NativeLibrary.X86Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Smush(IntPtr image, IntPtr offset, [MarshalAs(UnmanagedType.Bool)] bool stack, out IntPtr exception);
                [DllImport(NativeLibrary.X86Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern void MagickImageCollection_WriteFile(IntPtr image, IntPtr settings, out IntPtr exception);
                [DllImport(NativeLibrary.X86Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern void MagickImageCollection_WriteStream(IntPtr image, IntPtr settings, ReadWriteStreamDelegate? writer, SeekStreamDelegate? seeker, TellStreamDelegate? teller, ReadWriteStreamDelegate? reader, out IntPtr exception);
            }
            #endif
            #if PLATFORM_Arm64 || PLATFORM_AnyCPU
            public static class Arm64
            {
                #if PLATFORM_AnyCPU
                static Arm64() { NativeLibraryLoader.Load(); }
                #endif
                [DllImport(NativeLibrary.Arm64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Append(IntPtr image, [MarshalAs(UnmanagedType.Bool)] bool stack, out IntPtr exception);
                [DllImport(NativeLibrary.Arm64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Coalesce(IntPtr image, out IntPtr exception);
                [DllImport(NativeLibrary.Arm64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Combine(IntPtr image, UIntPtr colorSpace, out IntPtr exception);
                [DllImport(NativeLibrary.Arm64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Complex(IntPtr image, UIntPtr complexOperator, out IntPtr exception);
                [DllImport(NativeLibrary.Arm64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Deconstruct(IntPtr image, out IntPtr exception);
                [DllImport(NativeLibrary.Arm64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern void MagickImageCollection_Dispose(IntPtr value);
                [DllImport(NativeLibrary.Arm64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Evaluate(IntPtr image, UIntPtr evaluateOperator, out IntPtr exception);
                [DllImport(NativeLibrary.Arm64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern void MagickImageCollection_Map(IntPtr image, IntPtr settings, IntPtr remapImage, out IntPtr exception);
                [DllImport(NativeLibrary.Arm64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Merge(IntPtr image, UIntPtr method, out IntPtr exception);
                [DllImport(NativeLibrary.Arm64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Montage(IntPtr image, IntPtr settings, out IntPtr exception);
                [DllImport(NativeLibrary.Arm64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Morph(IntPtr image, UIntPtr frames, out IntPtr exception);
                [DllImport(NativeLibrary.Arm64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Optimize(IntPtr image, out IntPtr exception);
                [DllImport(NativeLibrary.Arm64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_OptimizePlus(IntPtr image, out IntPtr exception);
                [DllImport(NativeLibrary.Arm64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern void MagickImageCollection_OptimizeTransparency(IntPtr image, out IntPtr exception);
                [DllImport(NativeLibrary.Arm64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Polynomial(IntPtr image, double* terms, UIntPtr length, out IntPtr exception);
                [DllImport(NativeLibrary.Arm64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern void MagickImageCollection_Quantize(IntPtr image, IntPtr settings, out IntPtr exception);
                [DllImport(NativeLibrary.Arm64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_ReadBlob(IntPtr settings, byte* data, UIntPtr offset, UIntPtr length, out IntPtr exception);
                [DllImport(NativeLibrary.Arm64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_ReadFile(IntPtr settings, out IntPtr exception);
                [DllImport(NativeLibrary.Arm64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_ReadStream(IntPtr settings, ReadWriteStreamDelegate? reader, SeekStreamDelegate? seeker, TellStreamDelegate? teller, out IntPtr exception);
                [DllImport(NativeLibrary.Arm64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern IntPtr MagickImageCollection_Smush(IntPtr image, IntPtr offset, [MarshalAs(UnmanagedType.Bool)] bool stack, out IntPtr exception);
                [DllImport(NativeLibrary.Arm64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern void MagickImageCollection_WriteFile(IntPtr image, IntPtr settings, out IntPtr exception);
                [DllImport(NativeLibrary.Arm64Name, CallingConvention = CallingConvention.Cdecl)]
                public static extern void MagickImageCollection_WriteStream(IntPtr image, IntPtr settings, ReadWriteStreamDelegate? writer, SeekStreamDelegate? seeker, TellStreamDelegate? teller, ReadWriteStreamDelegate? reader, out IntPtr exception);
            }
            #endif
        }
        private unsafe sealed class NativeMagickImageCollection : NativeHelper
        {
            static NativeMagickImageCollection() { Environment.Initialize(); }
            public IntPtr Append(IMagickImage? image, bool stack)
            {
                IntPtr exception = IntPtr.Zero;
                IntPtr result;
                switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
                {
                #if PLATFORM_x64 || PLATFORM_AnyCPU
                case Architecture.X64:
                     result = NativeMethods.X64.MagickImageCollection_Append(MagickImage.GetInstance(image), stack, out exception);
                     break;
                #endif
                #if PLATFORM_x86 || PLATFORM_AnyCPU
                case Architecture.X86:
                     result = NativeMethods.X86.MagickImageCollection_Append(MagickImage.GetInstance(image), stack, out exception);
                     break;
                #endif
                #if PLATFORM_Arm64 || PLATFORM_AnyCPU
                case Architecture.Arm64:
                     result = NativeMethods.Arm64.MagickImageCollection_Append(MagickImage.GetInstance(image), stack, out exception);
                     break;
                #endif
                default:
                     throw new NotSupportedException("Processor architecture not supported.");
                }
                var magickException = MagickExceptionHelper.Create(exception);
                if (magickException == null)
                    return result;
                if (magickException is MagickErrorException)
                {
                    if (result != IntPtr.Zero)
                        Dispose(result);
                    throw magickException;
                }
                RaiseWarning(magickException);
                return result;
            }
            public IntPtr Coalesce(IMagickImage? image)
            {
                IntPtr exception = IntPtr.Zero;
                IntPtr result;
                switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
                {
                #if PLATFORM_x64 || PLATFORM_AnyCPU
                case Architecture.X64:
                     result = NativeMethods.X64.MagickImageCollection_Coalesce(MagickImage.GetInstance(image), out exception);
                     break;
                #endif
                #if PLATFORM_x86 || PLATFORM_AnyCPU
                case Architecture.X86:
                     result = NativeMethods.X86.MagickImageCollection_Coalesce(MagickImage.GetInstance(image), out exception);
                     break;
                #endif
                #if PLATFORM_Arm64 || PLATFORM_AnyCPU
                case Architecture.Arm64:
                     result = NativeMethods.Arm64.MagickImageCollection_Coalesce(MagickImage.GetInstance(image), out exception);
                     break;
                #endif
                default:
                     throw new NotSupportedException("Processor architecture not supported.");
                }
                var magickException = MagickExceptionHelper.Create(exception);
                if (magickException == null)
                    return result;
                if (magickException is MagickErrorException)
                {
                    if (result != IntPtr.Zero)
                        Dispose(result);
                    throw magickException;
                }
                RaiseWarning(magickException);
                return result;
            }
            public IntPtr Combine(IMagickImage? image, ColorSpace colorSpace)
            {
                IntPtr exception = IntPtr.Zero;
                IntPtr result;
                switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
                {
                #if PLATFORM_x64 || PLATFORM_AnyCPU
                case Architecture.X64:
                     result = NativeMethods.X64.MagickImageCollection_Combine(MagickImage.GetInstance(image), (UIntPtr)colorSpace, out exception);
                     break;
                #endif
                #if PLATFORM_x86 || PLATFORM_AnyCPU
                case Architecture.X86:
                     result = NativeMethods.X86.MagickImageCollection_Combine(MagickImage.GetInstance(image), (UIntPtr)colorSpace, out exception);
                     break;
                #endif
                #if PLATFORM_Arm64 || PLATFORM_AnyCPU
                case Architecture.Arm64:
                     result = NativeMethods.Arm64.MagickImageCollection_Combine(MagickImage.GetInstance(image), (UIntPtr)colorSpace, out exception);
                     break;
                #endif
                default:
                     throw new NotSupportedException("Processor architecture not supported.");
                }
                var magickException = MagickExceptionHelper.Create(exception);
                if (magickException == null)
                    return result;
                if (magickException is MagickErrorException)
                {
                    if (result != IntPtr.Zero)
                        Dispose(result);
                    throw magickException;
                }
                RaiseWarning(magickException);
                return result;
            }
            public IntPtr Complex(IMagickImage? image, ComplexOperator complexOperator)
            {
                IntPtr exception = IntPtr.Zero;
                IntPtr result;
                switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
                {
                #if PLATFORM_x64 || PLATFORM_AnyCPU
                case Architecture.X64:
                     result = NativeMethods.X64.MagickImageCollection_Complex(MagickImage.GetInstance(image), (UIntPtr)complexOperator, out exception);
                     break;
                #endif
                #if PLATFORM_x86 || PLATFORM_AnyCPU
                case Architecture.X86:
                     result = NativeMethods.X86.MagickImageCollection_Complex(MagickImage.GetInstance(image), (UIntPtr)complexOperator, out exception);
                     break;
                #endif
                #if PLATFORM_Arm64 || PLATFORM_AnyCPU
                case Architecture.Arm64:
                     result = NativeMethods.Arm64.MagickImageCollection_Complex(MagickImage.GetInstance(image), (UIntPtr)complexOperator, out exception);
                     break;
                #endif
                default:
                     throw new NotSupportedException("Processor architecture not supported.");
                }
                var magickException = MagickExceptionHelper.Create(exception);
                if (magickException == null)
                    return result;
                if (magickException is MagickErrorException)
                {
                    if (result != IntPtr.Zero)
                        Dispose(result);
                    throw magickException;
                }
                RaiseWarning(magickException);
                return result;
            }
            public IntPtr Deconstruct(IMagickImage? image)
            {
                IntPtr exception = IntPtr.Zero;
                IntPtr result;
                switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
                {
                #if PLATFORM_x64 || PLATFORM_AnyCPU
                case Architecture.X64:
                     result = NativeMethods.X64.MagickImageCollection_Deconstruct(MagickImage.GetInstance(image), out exception);
                     break;
                #endif
                #if PLATFORM_x86 || PLATFORM_AnyCPU
                case Architecture.X86:
                     result = NativeMethods.X86.MagickImageCollection_Deconstruct(MagickImage.GetInstance(image), out exception);
                     break;
                #endif
                #if PLATFORM_Arm64 || PLATFORM_AnyCPU
                case Architecture.Arm64:
                     result = NativeMethods.Arm64.MagickImageCollection_Deconstruct(MagickImage.GetInstance(image), out exception);
                     break;
                #endif
                default:
                     throw new NotSupportedException("Processor architecture not supported.");
                }
                var magickException = MagickExceptionHelper.Create(exception);
                if (magickException == null)
                    return result;
                if (magickException is MagickErrorException)
                {
                    if (result != IntPtr.Zero)
                        Dispose(result);
                    throw magickException;
                }
                RaiseWarning(magickException);
                return result;
            }
            public static void Dispose(IntPtr value)
            {
                switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
                {
                #if PLATFORM_x64 || PLATFORM_AnyCPU
                case Architecture.X64:
                     NativeMethods.X64.MagickImageCollection_Dispose(value);
                     break;
                #endif
                #if PLATFORM_x86 || PLATFORM_AnyCPU
                case Architecture.X86:
                     NativeMethods.X86.MagickImageCollection_Dispose(value);
                     break;
                #endif
                #if PLATFORM_Arm64 || PLATFORM_AnyCPU
                case Architecture.Arm64:
                     NativeMethods.Arm64.MagickImageCollection_Dispose(value);
                     break;
                #endif
                default:
                     throw new NotSupportedException("Processor architecture not supported.");
                }
            }
            public IntPtr Evaluate(IMagickImage? image, EvaluateOperator evaluateOperator)
            {
                IntPtr exception = IntPtr.Zero;
                IntPtr result;
                switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
                {
                #if PLATFORM_x64 || PLATFORM_AnyCPU
                case Architecture.X64:
                     result = NativeMethods.X64.MagickImageCollection_Evaluate(MagickImage.GetInstance(image), (UIntPtr)evaluateOperator, out exception);
                     break;
                #endif
                #if PLATFORM_x86 || PLATFORM_AnyCPU
                case Architecture.X86:
                     result = NativeMethods.X86.MagickImageCollection_Evaluate(MagickImage.GetInstance(image), (UIntPtr)evaluateOperator, out exception);
                     break;
                #endif
                #if PLATFORM_Arm64 || PLATFORM_AnyCPU
                case Architecture.Arm64:
                     result = NativeMethods.Arm64.MagickImageCollection_Evaluate(MagickImage.GetInstance(image), (UIntPtr)evaluateOperator, out exception);
                     break;
                #endif
                default:
                     throw new NotSupportedException("Processor architecture not supported.");
                }
                var magickException = MagickExceptionHelper.Create(exception);
                if (magickException == null)
                    return result;
                if (magickException is MagickErrorException)
                {
                    if (result != IntPtr.Zero)
                        Dispose(result);
                    throw magickException;
                }
                RaiseWarning(magickException);
                return result;
            }
            public void Map(IMagickImage? image, IQuantizeSettings? settings, IMagickImage? remapImage)
            {
                using (var settingsNative = QuantizeSettings.CreateInstance(settings))
                {
                    IntPtr exception = IntPtr.Zero;
                    switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
                    {
                    #if PLATFORM_x64 || PLATFORM_AnyCPU
                    case Architecture.X64:
                         NativeMethods.X64.MagickImageCollection_Map(MagickImage.GetInstance(image), settingsNative.Instance, MagickImage.GetInstance(remapImage), out exception);
                         break;
                    #endif
                    #if PLATFORM_x86 || PLATFORM_AnyCPU
                    case Architecture.X86:
                         NativeMethods.X86.MagickImageCollection_Map(MagickImage.GetInstance(image), settingsNative.Instance, MagickImage.GetInstance(remapImage), out exception);
                         break;
                    #endif
                    #if PLATFORM_Arm64 || PLATFORM_AnyCPU
                    case Architecture.Arm64:
                         NativeMethods.Arm64.MagickImageCollection_Map(MagickImage.GetInstance(image), settingsNative.Instance, MagickImage.GetInstance(remapImage), out exception);
                         break;
                    #endif
                    default:
                         throw new NotSupportedException("Processor architecture not supported.");
                    }
                    CheckException(exception);
                }
            }
            public IntPtr Merge(IMagickImage? image, LayerMethod method)
            {
                IntPtr exception = IntPtr.Zero;
                IntPtr result;
                switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
                {
                #if PLATFORM_x64 || PLATFORM_AnyCPU
                case Architecture.X64:
                     result = NativeMethods.X64.MagickImageCollection_Merge(MagickImage.GetInstance(image), (UIntPtr)method, out exception);
                     break;
                #endif
                #if PLATFORM_x86 || PLATFORM_AnyCPU
                case Architecture.X86:
                     result = NativeMethods.X86.MagickImageCollection_Merge(MagickImage.GetInstance(image), (UIntPtr)method, out exception);
                     break;
                #endif
                #if PLATFORM_Arm64 || PLATFORM_AnyCPU
                case Architecture.Arm64:
                     result = NativeMethods.Arm64.MagickImageCollection_Merge(MagickImage.GetInstance(image), (UIntPtr)method, out exception);
                     break;
                #endif
                default:
                     throw new NotSupportedException("Processor architecture not supported.");
                }
                var magickException = MagickExceptionHelper.Create(exception);
                if (magickException == null)
                    return result;
                if (magickException is MagickErrorException)
                {
                    if (result != IntPtr.Zero)
                        Dispose(result);
                    throw magickException;
                }
                RaiseWarning(magickException);
                return result;
            }
            public IntPtr Montage(IMagickImage? image, IMontageSettings<QuantumType>? settings)
            {
                using (var settingsNative = MontageSettings.CreateInstance(settings))
                {
                    IntPtr exception = IntPtr.Zero;
                    IntPtr result;
                    switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
                    {
                    #if PLATFORM_x64 || PLATFORM_AnyCPU
                    case Architecture.X64:
                         result = NativeMethods.X64.MagickImageCollection_Montage(MagickImage.GetInstance(image), settingsNative.Instance, out exception);
                         break;
                    #endif
                    #if PLATFORM_x86 || PLATFORM_AnyCPU
                    case Architecture.X86:
                         result = NativeMethods.X86.MagickImageCollection_Montage(MagickImage.GetInstance(image), settingsNative.Instance, out exception);
                         break;
                    #endif
                    #if PLATFORM_Arm64 || PLATFORM_AnyCPU
                    case Architecture.Arm64:
                         result = NativeMethods.Arm64.MagickImageCollection_Montage(MagickImage.GetInstance(image), settingsNative.Instance, out exception);
                         break;
                    #endif
                    default:
                         throw new NotSupportedException("Processor architecture not supported.");
                    }
                    var magickException = MagickExceptionHelper.Create(exception);
                    if (magickException == null)
                        return result;
                    if (magickException is MagickErrorException)
                    {
                        if (result != IntPtr.Zero)
                            Dispose(result);
                        throw magickException;
                    }
                    RaiseWarning(magickException);
                    return result;
                }
            }
            public IntPtr Morph(IMagickImage? image, int frames)
            {
                IntPtr exception = IntPtr.Zero;
                IntPtr result;
                switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
                {
                #if PLATFORM_x64 || PLATFORM_AnyCPU
                case Architecture.X64:
                     result = NativeMethods.X64.MagickImageCollection_Morph(MagickImage.GetInstance(image), (UIntPtr)frames, out exception);
                     break;
                #endif
                #if PLATFORM_x86 || PLATFORM_AnyCPU
                case Architecture.X86:
                     result = NativeMethods.X86.MagickImageCollection_Morph(MagickImage.GetInstance(image), (UIntPtr)frames, out exception);
                     break;
                #endif
                #if PLATFORM_Arm64 || PLATFORM_AnyCPU
                case Architecture.Arm64:
                     result = NativeMethods.Arm64.MagickImageCollection_Morph(MagickImage.GetInstance(image), (UIntPtr)frames, out exception);
                     break;
                #endif
                default:
                     throw new NotSupportedException("Processor architecture not supported.");
                }
                var magickException = MagickExceptionHelper.Create(exception);
                if (magickException == null)
                    return result;
                if (magickException is MagickErrorException)
                {
                    if (result != IntPtr.Zero)
                        Dispose(result);
                    throw magickException;
                }
                RaiseWarning(magickException);
                return result;
            }
            public IntPtr Optimize(IMagickImage? image)
            {
                IntPtr exception = IntPtr.Zero;
                IntPtr result;
                switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
                {
                #if PLATFORM_x64 || PLATFORM_AnyCPU
                case Architecture.X64:
                     result = NativeMethods.X64.MagickImageCollection_Optimize(MagickImage.GetInstance(image), out exception);
                     break;
                #endif
                #if PLATFORM_x86 || PLATFORM_AnyCPU
                case Architecture.X86:
                     result = NativeMethods.X86.MagickImageCollection_Optimize(MagickImage.GetInstance(image), out exception);
                     break;
                #endif
                #if PLATFORM_Arm64 || PLATFORM_AnyCPU
                case Architecture.Arm64:
                     result = NativeMethods.Arm64.MagickImageCollection_Optimize(MagickImage.GetInstance(image), out exception);
                     break;
                #endif
                default:
                     throw new NotSupportedException("Processor architecture not supported.");
                }
                var magickException = MagickExceptionHelper.Create(exception);
                if (magickException == null)
                    return result;
                if (magickException is MagickErrorException)
                {
                    if (result != IntPtr.Zero)
                        Dispose(result);
                    throw magickException;
                }
                RaiseWarning(magickException);
                return result;
            }
            public IntPtr OptimizePlus(IMagickImage? image)
            {
                IntPtr exception = IntPtr.Zero;
                IntPtr result;
                switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
                {
                #if PLATFORM_x64 || PLATFORM_AnyCPU
                case Architecture.X64:
                     result = NativeMethods.X64.MagickImageCollection_OptimizePlus(MagickImage.GetInstance(image), out exception);
                     break;
                #endif
                #if PLATFORM_x86 || PLATFORM_AnyCPU
                case Architecture.X86:
                     result = NativeMethods.X86.MagickImageCollection_OptimizePlus(MagickImage.GetInstance(image), out exception);
                     break;
                #endif
                #if PLATFORM_Arm64 || PLATFORM_AnyCPU
                case Architecture.Arm64:
                     result = NativeMethods.Arm64.MagickImageCollection_OptimizePlus(MagickImage.GetInstance(image), out exception);
                     break;
                #endif
                default:
                     throw new NotSupportedException("Processor architecture not supported.");
                }
                var magickException = MagickExceptionHelper.Create(exception);
                if (magickException == null)
                    return result;
                if (magickException is MagickErrorException)
                {
                    if (result != IntPtr.Zero)
                        Dispose(result);
                    throw magickException;
                }
                RaiseWarning(magickException);
                return result;
            }
            public void OptimizeTransparency(IMagickImage? image)
            {
                IntPtr exception = IntPtr.Zero;
                switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
                {
                #if PLATFORM_x64 || PLATFORM_AnyCPU
                case Architecture.X64:
                     NativeMethods.X64.MagickImageCollection_OptimizeTransparency(MagickImage.GetInstance(image), out exception);
                     break;
                #endif
                #if PLATFORM_x86 || PLATFORM_AnyCPU
                case Architecture.X86:
                     NativeMethods.X86.MagickImageCollection_OptimizeTransparency(MagickImage.GetInstance(image), out exception);
                     break;
                #endif
                #if PLATFORM_Arm64 || PLATFORM_AnyCPU
                case Architecture.Arm64:
                     NativeMethods.Arm64.MagickImageCollection_OptimizeTransparency(MagickImage.GetInstance(image), out exception);
                     break;
                #endif
                default:
                     throw new NotSupportedException("Processor architecture not supported.");
                }
                CheckException(exception);
            }
            public IntPtr Polynomial(IMagickImage? image, double[] terms, int length)
            {
                fixed (double* termsFixed = terms)
                {
                    IntPtr exception = IntPtr.Zero;
                    IntPtr result;
                    switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
                    {
                    #if PLATFORM_x64 || PLATFORM_AnyCPU
                    case Architecture.X64:
                         result = NativeMethods.X64.MagickImageCollection_Polynomial(MagickImage.GetInstance(image), termsFixed, (UIntPtr)length, out exception);
                         break;
                    #endif
                    #if PLATFORM_x86 || PLATFORM_AnyCPU
                    case Architecture.X86:
                         result = NativeMethods.X86.MagickImageCollection_Polynomial(MagickImage.GetInstance(image), termsFixed, (UIntPtr)length, out exception);
                         break;
                    #endif
                    #if PLATFORM_Arm64 || PLATFORM_AnyCPU
                    case Architecture.Arm64:
                         result = NativeMethods.Arm64.MagickImageCollection_Polynomial(MagickImage.GetInstance(image), termsFixed, (UIntPtr)length, out exception);
                         break;
                    #endif
                    default:
                         throw new NotSupportedException("Processor architecture not supported.");
                    }
                    var magickException = MagickExceptionHelper.Create(exception);
                    if (magickException == null)
                        return result;
                    if (magickException is MagickErrorException)
                    {
                        if (result != IntPtr.Zero)
                            Dispose(result);
                        throw magickException;
                    }
                    RaiseWarning(magickException);
                    return result;
                }
            }
            public void Quantize(IMagickImage? image, IQuantizeSettings? settings)
            {
                using (var settingsNative = QuantizeSettings.CreateInstance(settings))
                {
                    IntPtr exception = IntPtr.Zero;
                    switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
                    {
                    #if PLATFORM_x64 || PLATFORM_AnyCPU
                    case Architecture.X64:
                         NativeMethods.X64.MagickImageCollection_Quantize(MagickImage.GetInstance(image), settingsNative.Instance, out exception);
                         break;
                    #endif
                    #if PLATFORM_x86 || PLATFORM_AnyCPU
                    case Architecture.X86:
                         NativeMethods.X86.MagickImageCollection_Quantize(MagickImage.GetInstance(image), settingsNative.Instance, out exception);
                         break;
                    #endif
                    #if PLATFORM_Arm64 || PLATFORM_AnyCPU
                    case Architecture.Arm64:
                         NativeMethods.Arm64.MagickImageCollection_Quantize(MagickImage.GetInstance(image), settingsNative.Instance, out exception);
                         break;
                    #endif
                    default:
                         throw new NotSupportedException("Processor architecture not supported.");
                    }
                    CheckException(exception);
                }
            }
            public IntPtr ReadBlob(IMagickSettings<QuantumType>? settings, byte[] data, int offset, int length)
            {
                using (var settingsNative = MagickSettings.CreateInstance(settings))
                {
                    fixed (byte* dataFixed = data)
                    {
                        IntPtr exception = IntPtr.Zero;
                        IntPtr result;
                        switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
                        {
                        #if PLATFORM_x64 || PLATFORM_AnyCPU
                        case Architecture.X64:
                             result = NativeMethods.X64.MagickImageCollection_ReadBlob(settingsNative.Instance, dataFixed, (UIntPtr)offset, (UIntPtr)length, out exception);
                             break;
                        #endif
                        #if PLATFORM_x86 || PLATFORM_AnyCPU
                        case Architecture.X86:
                             result = NativeMethods.X86.MagickImageCollection_ReadBlob(settingsNative.Instance, dataFixed, (UIntPtr)offset, (UIntPtr)length, out exception);
                             break;
                        #endif
                        #if PLATFORM_Arm64 || PLATFORM_AnyCPU
                        case Architecture.Arm64:
                             result = NativeMethods.Arm64.MagickImageCollection_ReadBlob(settingsNative.Instance, dataFixed, (UIntPtr)offset, (UIntPtr)length, out exception);
                             break;
                        #endif
                        default:
                             throw new NotSupportedException("Processor architecture not supported.");
                        }
                        var magickException = MagickExceptionHelper.Create(exception);
                        if (magickException == null)
                            return result;
                        if (magickException is MagickErrorException)
                        {
                            if (result != IntPtr.Zero)
                                Dispose(result);
                            throw magickException;
                        }
                        RaiseWarning(magickException);
                        return result;
                    }
                }
            }
            #if NETSTANDARD2_1
            public IntPtr ReadBlob(IMagickSettings<QuantumType>? settings, ReadOnlySpan<byte> data, int offset, int length)
            {
                using (var settingsNative = MagickSettings.CreateInstance(settings))
                {
                    fixed (byte* dataFixed = data)
                    {
                        IntPtr exception = IntPtr.Zero;
                        IntPtr result;
                        switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
                        {
                        #if PLATFORM_x64 || PLATFORM_AnyCPU
                        case Architecture.X64:
                             result = NativeMethods.X64.MagickImageCollection_ReadBlob(settingsNative.Instance, dataFixed, (UIntPtr)offset, (UIntPtr)length, out exception);
                             break;
                        #endif
                        #if PLATFORM_x86 || PLATFORM_AnyCPU
                        case Architecture.X86:
                             result = NativeMethods.X86.MagickImageCollection_ReadBlob(settingsNative.Instance, dataFixed, (UIntPtr)offset, (UIntPtr)length, out exception);
                             break;
                        #endif
                        #if PLATFORM_Arm64 || PLATFORM_AnyCPU
                        case Architecture.Arm64:
                             result = NativeMethods.Arm64.MagickImageCollection_ReadBlob(settingsNative.Instance, dataFixed, (UIntPtr)offset, (UIntPtr)length, out exception);
                             break;
                        #endif
                        default:
                             throw new NotSupportedException("Processor architecture not supported.");
                        }
                        var magickException = MagickExceptionHelper.Create(exception);
                        if (magickException == null)
                            return result;
                        if (magickException is MagickErrorException)
                        {
                            if (result != IntPtr.Zero)
                                Dispose(result);
                            throw magickException;
                        }
                        RaiseWarning(magickException);
                        return result;
                    }
                }
            }
            #endif
            public IntPtr ReadFile(IMagickSettings<QuantumType>? settings)
            {
                using (var settingsNative = MagickSettings.CreateInstance(settings))
                {
                    IntPtr exception = IntPtr.Zero;
                    IntPtr result;
                    switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
                    {
                    #if PLATFORM_x64 || PLATFORM_AnyCPU
                    case Architecture.X64:
                         result = NativeMethods.X64.MagickImageCollection_ReadFile(settingsNative.Instance, out exception);
                         break;
                    #endif
                    #if PLATFORM_x86 || PLATFORM_AnyCPU
                    case Architecture.X86:
                         result = NativeMethods.X86.MagickImageCollection_ReadFile(settingsNative.Instance, out exception);
                         break;
                    #endif
                    #if PLATFORM_Arm64 || PLATFORM_AnyCPU
                    case Architecture.Arm64:
                         result = NativeMethods.Arm64.MagickImageCollection_ReadFile(settingsNative.Instance, out exception);
                         break;
                    #endif
                    default:
                         throw new NotSupportedException("Processor architecture not supported.");
                    }
                    var magickException = MagickExceptionHelper.Create(exception);
                    if (magickException == null)
                        return result;
                    if (magickException is MagickErrorException)
                    {
                        if (result != IntPtr.Zero)
                            Dispose(result);
                        throw magickException;
                    }
                    RaiseWarning(magickException);
                    return result;
                }
            }
            public IntPtr ReadStream(IMagickSettings<QuantumType>? settings, ReadWriteStreamDelegate? reader, SeekStreamDelegate? seeker, TellStreamDelegate? teller)
            {
                using (var settingsNative = MagickSettings.CreateInstance(settings))
                {
                    IntPtr exception = IntPtr.Zero;
                    IntPtr result;
                    switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
                    {
                    #if PLATFORM_x64 || PLATFORM_AnyCPU
                    case Architecture.X64:
                         result = NativeMethods.X64.MagickImageCollection_ReadStream(settingsNative.Instance, reader, seeker, teller, out exception);
                         break;
                    #endif
                    #if PLATFORM_x86 || PLATFORM_AnyCPU
                    case Architecture.X86:
                         result = NativeMethods.X86.MagickImageCollection_ReadStream(settingsNative.Instance, reader, seeker, teller, out exception);
                         break;
                    #endif
                    #if PLATFORM_Arm64 || PLATFORM_AnyCPU
                    case Architecture.Arm64:
                         result = NativeMethods.Arm64.MagickImageCollection_ReadStream(settingsNative.Instance, reader, seeker, teller, out exception);
                         break;
                    #endif
                    default:
                         throw new NotSupportedException("Processor architecture not supported.");
                    }
                    var magickException = MagickExceptionHelper.Create(exception);
                    if (magickException == null)
                        return result;
                    if (magickException is MagickErrorException)
                    {
                        if (result != IntPtr.Zero)
                            Dispose(result);
                        throw magickException;
                    }
                    RaiseWarning(magickException);
                    return result;
                }
            }
            public IntPtr Smush(IMagickImage? image, int offset, bool stack)
            {
                IntPtr exception = IntPtr.Zero;
                IntPtr result;
                switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
                {
                #if PLATFORM_x64 || PLATFORM_AnyCPU
                case Architecture.X64:
                     result = NativeMethods.X64.MagickImageCollection_Smush(MagickImage.GetInstance(image), (IntPtr)offset, stack, out exception);
                     break;
                #endif
                #if PLATFORM_x86 || PLATFORM_AnyCPU
                case Architecture.X86:
                     result = NativeMethods.X86.MagickImageCollection_Smush(MagickImage.GetInstance(image), (IntPtr)offset, stack, out exception);
                     break;
                #endif
                #if PLATFORM_Arm64 || PLATFORM_AnyCPU
                case Architecture.Arm64:
                     result = NativeMethods.Arm64.MagickImageCollection_Smush(MagickImage.GetInstance(image), (IntPtr)offset, stack, out exception);
                     break;
                #endif
                default:
                     throw new NotSupportedException("Processor architecture not supported.");
                }
                var magickException = MagickExceptionHelper.Create(exception);
                if (magickException == null)
                    return result;
                if (magickException is MagickErrorException)
                {
                    if (result != IntPtr.Zero)
                        Dispose(result);
                    throw magickException;
                }
                RaiseWarning(magickException);
                return result;
            }
            public void WriteFile(IMagickImage? image, IMagickSettings<QuantumType>? settings)
            {
                using (var settingsNative = MagickSettings.CreateInstance(settings))
                {
                    IntPtr exception = IntPtr.Zero;
                    switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
                    {
                    #if PLATFORM_x64 || PLATFORM_AnyCPU
                    case Architecture.X64:
                         NativeMethods.X64.MagickImageCollection_WriteFile(MagickImage.GetInstance(image), settingsNative.Instance, out exception);
                         break;
                    #endif
                    #if PLATFORM_x86 || PLATFORM_AnyCPU
                    case Architecture.X86:
                         NativeMethods.X86.MagickImageCollection_WriteFile(MagickImage.GetInstance(image), settingsNative.Instance, out exception);
                         break;
                    #endif
                    #if PLATFORM_Arm64 || PLATFORM_AnyCPU
                    case Architecture.Arm64:
                         NativeMethods.Arm64.MagickImageCollection_WriteFile(MagickImage.GetInstance(image), settingsNative.Instance, out exception);
                         break;
                    #endif
                    default:
                         throw new NotSupportedException("Processor architecture not supported.");
                    }
                    CheckException(exception);
                }
            }
            public void WriteStream(IMagickImage? image, IMagickSettings<QuantumType>? settings, ReadWriteStreamDelegate? writer, SeekStreamDelegate? seeker, TellStreamDelegate? teller, ReadWriteStreamDelegate? reader)
            {
                using (var settingsNative = MagickSettings.CreateInstance(settings))
                {
                    IntPtr exception = IntPtr.Zero;
                    switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
                    {
                    #if PLATFORM_x64 || PLATFORM_AnyCPU
                    case Architecture.X64:
                         NativeMethods.X64.MagickImageCollection_WriteStream(MagickImage.GetInstance(image), settingsNative.Instance, writer, seeker, teller, reader, out exception);
                         break;
                    #endif
                    #if PLATFORM_x86 || PLATFORM_AnyCPU
                    case Architecture.X86:
                         NativeMethods.X86.MagickImageCollection_WriteStream(MagickImage.GetInstance(image), settingsNative.Instance, writer, seeker, teller, reader, out exception);
                         break;
                    #endif
                    #if PLATFORM_Arm64 || PLATFORM_AnyCPU
                    case Architecture.Arm64:
                         NativeMethods.Arm64.MagickImageCollection_WriteStream(MagickImage.GetInstance(image), settingsNative.Instance, writer, seeker, teller, reader, out exception);
                         break;
                    #endif
                    default:
                         throw new NotSupportedException("Processor architecture not supported.");
                    }
                    CheckException(exception);
                }
            }
        }
    }
}
